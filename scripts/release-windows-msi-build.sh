#!/bin/bash
#
# release-windows-msi-build.sh - Build MSI Installer for Windows on Rescale
#
# This script builds the MSI installer for Windows:
# 1. Installs Go 1.24.2, .NET SDK, Git, and WiX Toolset
# 2. Clones the repository
# 3. Builds the binaries with FIPS 140-3 compliance
# 4. Creates the MSI installer using WiX v4
#
# Required environment variables:
#   RESCALE_API_KEY - Rescale API token
#   GITHUB_TOKEN - GitHub PAT with repo scope (for git clone)
#
# Output: RescaleInterlink-{version}.msi
#
# Usage:
#   ./release-windows-msi-build.sh
#
# Version: 4.0.2
# Date: 2026-01-01

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESCALE_INT_DIR="$(dirname "$SCRIPT_DIR")"
MAKEFILE="$RESCALE_INT_DIR/Makefile"

# Job configuration - Windows Server 2019
CORE_TYPE="calcitev2"
CORES_PER_SLOT=4
SLOTS=1
WALLTIME_HOURS=2

# GitHub repository
REPO_OWNER="rescale-labs"
REPO_NAME="Rescale_Interlink"

# =============================================================================
# Helper Functions
# =============================================================================
cleanup() {
    local exit_code=$?
    rm -f "/tmp/claude/interlink-msi-windows.ps1" 2>/dev/null || true
    rm -f "/tmp/claude/interlink-msi-windows.bat" 2>/dev/null || true
    if [ $exit_code -ne 0 ]; then
        echo ""
        echo "=============================================="
        echo "BUILD FAILED"
        echo "=============================================="
    fi
}
trap cleanup EXIT

error() {
    echo "ERROR: $1" >&2
    exit 1
}

# =============================================================================
# Pre-flight Checks
# =============================================================================
echo "=============================================="
echo "Rescale Interlink Windows MSI Builder"
echo "=============================================="
echo ""

[ -z "${RESCALE_API_KEY:-}" ] && error "RESCALE_API_KEY environment variable is not set"
[ -z "${GITHUB_TOKEN:-}" ] && error "GITHUB_TOKEN environment variable is not set"

[ ! -f "$MAKEFILE" ] && error "Makefile not found at: $MAKEFILE"

VERSION=$(grep -E '^VERSION\s*:=' "$MAKEFILE" | sed 's/.*:=\s*//' | tr -d '[:space:]')
[ -z "$VERSION" ] && error "Could not extract VERSION from Makefile"

BRANCH="release/${VERSION}"

echo "Version: $VERSION"
echo "Repository: ${REPO_OWNER}/${REPO_NAME}"
echo "Branch: ${BRANCH}"
echo ""

# Find rescale-int binary
RESCALE_INT_BIN="$RESCALE_INT_DIR/bin/${VERSION}/darwin-arm64/rescale-int"
if [ ! -x "$RESCALE_INT_BIN" ]; then
    RESCALE_INT_BIN=$(find "$RESCALE_INT_DIR/bin" -name "rescale-int" -type f 2>/dev/null | head -1)
fi
[ ! -x "$RESCALE_INT_BIN" ] && error "rescale-int binary not found. Please build it first with 'make build'"

echo "Using: $RESCALE_INT_BIN"
echo ""

# =============================================================================
# Generate Windows Build Scripts
# =============================================================================
echo "Generating Windows MSI build scripts..."

mkdir -p /tmp/claude
JOB_NAME="Interlink Windows Installer Build - ${VERSION}"

# Create wrapper batch file
WRAPPER_SCRIPT="/tmp/claude/interlink-msi-windows.bat"
cat > "$WRAPPER_SCRIPT" << 'WRAPPER_EOF'
@echo off
REM Wrapper to execute PowerShell MSI build script
echo ============================================
echo Starting PowerShell MSI build script...
echo ============================================

powershell.exe -ExecutionPolicy Bypass -File "%~dp0interlink-msi-windows.ps1"

echo ============================================
echo PowerShell script completed with exit code: %ERRORLEVEL%
echo ============================================
exit /b %ERRORLEVEL%
WRAPPER_EOF

# Create PowerShell build script
PS_SCRIPT="/tmp/claude/interlink-msi-windows.ps1"
cat > "$PS_SCRIPT" << PSHEADER
# Rescale Interlink Windows MSI Build Script
# Generated by release-windows-msi-build.sh
# Version: ${VERSION}

\$ErrorActionPreference = "Stop"

PSHEADER

# Add the main build logic
cat >> "$PS_SCRIPT" << 'PSBODY'
Write-Host "=============================================="
Write-Host "Rescale Interlink Windows MSI Build"
Write-Host "=============================================="
Write-Host "Release Tag: $env:RELEASE_TAG"
Write-Host "Repository: $env:REPO_OWNER/$env:REPO_NAME"
Write-Host "Started: $(Get-Date)"
Write-Host ""

# Set up paths
$WorkDir = $PWD.Path
$BuildDir = "C:\build"
$LogFile = Join-Path $WorkDir "build.log"

New-Item -ItemType Directory -Force -Path $BuildDir | Out-Null
Start-Transcript -Path $LogFile -Append

Write-Host "Build log: $LogFile"
Write-Host "Work directory: $WorkDir"
Write-Host "Build directory: $BuildDir"

Set-Location $BuildDir

$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# =============================================================================
# Helper Function: Ensure Chocolatey is installed
# =============================================================================
function Ensure-Chocolatey {
    if (Get-Command choco.exe -ErrorAction SilentlyContinue) {
        Write-Host "Chocolatey already installed"
        return
    }

    Write-Host "Installing Chocolatey..."
    Set-ExecutionPolicy Bypass -Scope Process -Force
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

    if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
        throw "Chocolatey installation failed"
    }
    Write-Host "Chocolatey installed successfully"
}

# =============================================================================
# Step 1: Install Go 1.24.2
# =============================================================================
Write-Host ""
Write-Host "[1/7] Installing Go 1.24.2..."

$GoVersion = "1.24.2"
$GoZip = "go${GoVersion}.windows-amd64.zip"
$GoUrl = "https://go.dev/dl/$GoZip"
$GoInstallDir = "C:\Go"

Write-Host "Downloading Go from: $GoUrl"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
(New-Object System.Net.WebClient).DownloadFile($GoUrl, (Join-Path $BuildDir $GoZip))

Write-Host "Extracting Go..."
if (Test-Path $GoInstallDir) {
    Remove-Item -Recurse -Force $GoInstallDir
}
Expand-Archive -Path (Join-Path $BuildDir $GoZip) -DestinationPath "C:\" -Force
Remove-Item (Join-Path $BuildDir $GoZip)

$env:PATH = "$GoInstallDir\bin;$env:PATH"
$env:GOPATH = "$env:USERPROFILE\go"
$env:PATH = "$env:GOPATH\bin;$env:PATH"

Write-Host "Go version:"
$goResult = cmd /c "go version 2>&1"
Write-Host $goResult

# =============================================================================
# Step 2: Install .NET SDK (for WiX v4)
# =============================================================================
Write-Host ""
Write-Host "[2/7] Installing .NET SDK..."

Ensure-Chocolatey

# Install .NET SDK using Chocolatey
# Temporarily allow errors since choco/dotnet output progress to stderr
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
choco install dotnet-sdk -y --no-progress --limit-output 2>&1 | Out-Host
$chocoExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

if ($chocoExitCode -ne 0) {
    throw ".NET SDK installation failed with exit code: $chocoExitCode"
}

# Refresh PATH
$env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" +
            [System.Environment]::GetEnvironmentVariable("PATH", "User") + ";" +
            "$GoInstallDir\bin;$env:GOPATH\bin"

Write-Host ".NET version:"
$dotnetResult = cmd /c "dotnet --version 2>&1"
Write-Host $dotnetResult

# =============================================================================
# Step 3: Install Git and Clone Repository
# =============================================================================
Write-Host ""
Write-Host "[3/7] Setting up Git and cloning repository..."

$GitPath = Get-Command git -ErrorAction SilentlyContinue
if (-not $GitPath) {
    Write-Host "Installing Git..."
    # Temporarily allow errors since choco outputs progress to stderr
    $prevErrorAction = $ErrorActionPreference
    $ErrorActionPreference = "Continue"
    choco install git -y --no-progress --limit-output 2>&1 | Out-Host
    $chocoExitCode = $LASTEXITCODE
    $ErrorActionPreference = $prevErrorAction

    if ($chocoExitCode -ne 0) {
        throw "Git installation failed with exit code: $chocoExitCode"
    }

    $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" +
                [System.Environment]::GetEnvironmentVariable("PATH", "User") + ";" +
                "$GoInstallDir\bin;$env:GOPATH\bin"
}

Write-Host "Git version:"
$gitResult = cmd /c "git --version 2>&1"
Write-Host $gitResult

$RepoUrl = "https://x-access-token:$($env:GITHUB_TOKEN)@github.com/$($env:REPO_OWNER)/$($env:REPO_NAME).git"
$BranchName = "release/$($env:RELEASE_TAG)"

Write-Host "Cloning repository (branch: $BranchName)..."
# Temporarily allow errors since git outputs progress to stderr
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
& git clone --depth 1 --branch $BranchName $RepoUrl 2>&1 | Out-Host
$cloneExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

if ($cloneExitCode -ne 0 -or -not (Test-Path $env:REPO_NAME)) {
    throw "Git clone failed with exit code: $cloneExitCode"
}
Write-Host "Repository cloned successfully"

# =============================================================================
# Step 4: Install WiX Toolset v4
# =============================================================================
Write-Host ""
Write-Host "[4/7] Installing WiX Toolset v4..."

# Temporarily allow errors since dotnet outputs info to stderr
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
dotnet tool install --global wix 2>&1 | Out-Host
$wixInstallExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

# Exit code 0 = success, exit code 1 may just mean "already installed" - check if wix is available
# Refresh PATH to include dotnet tools before checking
$env:PATH = "$env:USERPROFILE\.dotnet\tools;$env:PATH"

# Verify wix is available
$wixPath = Get-Command wix -ErrorAction SilentlyContinue
if (-not $wixPath) {
    throw "WiX Toolset installation failed - wix command not found"
}

# Install WiX UI extension (use cmd /c to avoid transcript console buffer conflicts)
Write-Host "Installing WiX UI extension..."
$wixExtResult = cmd /c "wix extension add WixToolset.UI.wixext -g 2>&1"
Write-Host $wixExtResult
# Note: wix extension add may return non-zero if already installed - that's OK

Write-Host "WiX version:"
# Use cmd /c wrapper to avoid PowerShell transcript console buffer conflicts
$wixVersionResult = cmd /c "wix --version 2>&1"
Write-Host $wixVersionResult

# =============================================================================
# Step 4.5: Install Node.js and Wails CLI (required for GUI build)
# =============================================================================
Write-Host ""
Write-Host "[4.5/7] Installing Node.js and Wails CLI..."

# Install Node.js via Chocolatey
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
choco install nodejs-lts -y --no-progress --limit-output 2>&1 | Out-Host
$nodeExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

if ($nodeExitCode -ne 0) {
    throw "Node.js installation failed with exit code: $nodeExitCode"
}

# Refresh PATH
$env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" +
            [System.Environment]::GetEnvironmentVariable("PATH", "User") + ";" +
            "$GoInstallDir\bin;$env:GOPATH\bin;$env:USERPROFILE\.dotnet\tools"

Write-Host "Node.js version:"
$nodeResult = cmd /c "node --version 2>&1"
Write-Host $nodeResult

# Install Wails CLI
Write-Host "Installing Wails CLI..."
$wailsInstallCmd = "go install github.com/wailsapp/wails/v2/cmd/wails@latest"
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
cmd /c $wailsInstallCmd 2>&1 | Out-Host
$wailsInstallExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

if ($wailsInstallExitCode -ne 0) {
    throw "Wails CLI installation failed with exit code: $wailsInstallExitCode"
}

Write-Host "Wails version:"
$wailsResult = cmd /c "$env:GOPATH\bin\wails.exe version 2>&1"
Write-Host $wailsResult

# =============================================================================
# Step 5: Build Wails Application
# =============================================================================
Write-Host ""
Write-Host "[5/7] Building Wails application with FIPS 140-3..."

Set-Location $env:REPO_NAME

$BuildTime = Get-Date -Format "yyyy-MM-dd"
$LdFlags = "-s -w -X main.Version=$($env:RELEASE_TAG) -X main.BuildTime=$BuildTime"

Write-Host "Build flags: GOFIPS140=latest"
Write-Host "LDFLAGS: $LdFlags"

# Create output directory
$BinDir = Join-Path $BuildDir "bin"
New-Item -ItemType Directory -Force -Path $BinDir | Out-Null

# Install frontend dependencies
Write-Host "Installing frontend dependencies..."
Set-Location frontend
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
cmd /c "npm install 2>&1" | Out-Host
$npmExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction
Set-Location ..

if ($npmExitCode -ne 0) {
    Write-Host "Warning: npm install returned exit code $npmExitCode (may be non-fatal warnings)"
}

# Build GUI binary using Wails (required for embedded frontend assets)
# NOTE: Must use wails build, not go build, because the app embeds frontend assets
Write-Host "Building rescale-int-gui.exe with Wails..."
$WailsExe = "$env:GOPATH\bin\wails.exe"
$wailsBuildCmd = "set `"GOFIPS140=latest`"&& `"$WailsExe`" build -platform windows/amd64 -ldflags `"$LdFlags`""
Write-Host "Running: $wailsBuildCmd"
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
cmd /c $wailsBuildCmd 2>&1 | Out-Host
$wailsBuildExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction

$WailsOutputExe = "build\bin\rescale-int.exe"
if ($wailsBuildExitCode -ne 0 -or -not (Test-Path $WailsOutputExe)) {
    throw "Wails build failed (exit code: $wailsBuildExitCode)"
}

# v4.0.2: Rename Wails output to rescale-int-gui.exe
Copy-Item $WailsOutputExe -Destination "$BinDir\rescale-int-gui.exe"
Write-Host "GUI binary built: rescale-int-gui.exe"

# v4.0.2: Build standalone CLI binary
Write-Host "Building rescale-int.exe (standalone CLI)..."
$GoExe = "C:\Go\bin\go.exe"
$cliBuildCmd = "set `"GOFIPS140=latest`"&& `"$GoExe`" build -ldflags `"$LdFlags`" -o `"$BinDir\rescale-int.exe`" .\cmd\rescale-int"
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
cmd /c $cliBuildCmd 2>&1 | Out-Host
$cliExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction
if ($cliExitCode -ne 0 -or -not (Test-Path "$BinDir\rescale-int.exe")) { throw "CLI build failed (exit code: $cliExitCode)" }
Write-Host "CLI binary built: rescale-int.exe"

# Build tray companion (windowsgui subsystem) - this is a separate simple Go app
Write-Host "Building rescale-int-tray.exe..."
$trayCmd = "set `"GOFIPS140=latest`"&& set `"GOOS=windows`"&& set `"GOARCH=amd64`"&& go build -ldflags `"$LdFlags -H=windowsgui`" -o `"$BinDir\rescale-int-tray.exe`" .\cmd\rescale-int-tray"
$prevErrorAction = $ErrorActionPreference
$ErrorActionPreference = "Continue"
cmd /c $trayCmd 2>&1 | Out-Host
$trayExitCode = $LASTEXITCODE
$ErrorActionPreference = $prevErrorAction
if ($trayExitCode -ne 0 -or -not (Test-Path "$BinDir\rescale-int-tray.exe")) { throw "Failed to build rescale-int-tray.exe (exit code: $trayExitCode)" }

Write-Host "Binaries built successfully"
Get-ChildItem $BinDir

# =============================================================================
# Step 5.5: Download and Bundle WebView2 Fixed Version Runtime
# =============================================================================
Write-Host ""
Write-Host "[5.5/7] Bundling WebView2 Fixed Version Runtime..."

$WebView2Dir = Join-Path $BinDir "webview2"
New-Item -ItemType Directory -Force -Path $WebView2Dir | Out-Null

# Download WebView2 Fixed Version Runtime from NuGet
# IMPORTANT: Use WebView2.Runtime.X64 package (contains actual runtime files)
# NOT Microsoft.Web.WebView2 (which is just the SDK with WebView2Loader.dll)
# See: https://github.com/ProKn1fe/WebView2.Runtime
$RuntimeNuGetUrl = "https://www.nuget.org/api/v2/package/WebView2.Runtime.X64"
$RuntimePkg = Join-Path $BuildDir "webview2-runtime.zip"

Write-Host "Downloading WebView2 Fixed Version Runtime (WebView2.Runtime.X64)..."
$hasWebView2 = $false

try {
    (New-Object System.Net.WebClient).DownloadFile($RuntimeNuGetUrl, $RuntimePkg)
    Write-Host "WebView2.Runtime.X64 package downloaded successfully"
    $pkgSize = (Get-Item $RuntimePkg).Length / 1MB
    Write-Host "Package size: $([math]::Round($pkgSize, 1)) MB"

    # Extract the NuGet package
    $RuntimeExtract = Join-Path $BuildDir "webview2-runtime-extract"
    Expand-Archive -Path $RuntimePkg -DestinationPath $RuntimeExtract -Force

    Write-Host "Searching for runtime files..."

    # Find msedgewebview2.exe in the extracted package
    $runtimeExe = Get-ChildItem -Path $RuntimeExtract -Recurse -Filter "msedgewebview2.exe" | Select-Object -First 1

    if ($runtimeExe) {
        $RuntimeSourceDir = $runtimeExe.DirectoryName
        Write-Host "Found runtime at: $RuntimeSourceDir"

        # Copy all runtime files
        Copy-Item -Path "$RuntimeSourceDir\*" -Destination $WebView2Dir -Recurse -Force
        $hasWebView2 = $true

        # v4.0.1: Strip unnecessary components to avoid path length issues and reduce size
        # - WidevineCdm: DRM for video playback - not needed for Interlink
        # - EBWebView/x86: 32-bit components - Interlink is 64-bit only
        Write-Host "Stripping unnecessary WebView2 components..."
        $strippedSize = 0

        $widevinePath = Join-Path $WebView2Dir "WidevineCdm"
        if (Test-Path $widevinePath) {
            $wvSize = (Get-ChildItem -Path $widevinePath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Remove-Item -Recurse $widevinePath -Force -ErrorAction SilentlyContinue
            Write-Host "  Removed WidevineCdm/ ($([math]::Round($wvSize, 1)) MB)"
            $strippedSize += $wvSize
        }

        $x86Path = Join-Path $WebView2Dir "EBWebView\x86"
        if (Test-Path $x86Path) {
            $x86Size = (Get-ChildItem -Path $x86Path -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Remove-Item -Recurse $x86Path -Force -ErrorAction SilentlyContinue
            Write-Host "  Removed EBWebView/x86/ ($([math]::Round($x86Size, 1)) MB)"
            $strippedSize += $x86Size
        }

        if ($strippedSize -gt 0) {
            Write-Host "  Total stripped: $([math]::Round($strippedSize, 1)) MB"
        }

        # Verify
        $copiedExe = Join-Path $WebView2Dir "msedgewebview2.exe"
        if (Test-Path $copiedExe) {
            Write-Host "SUCCESS: msedgewebview2.exe bundled for MSI"
            $fileCount = (Get-ChildItem -Path $WebView2Dir -Recurse).Count
            $totalSize = (Get-ChildItem -Path $WebView2Dir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Write-Host "WebView2 runtime: $fileCount files, $([math]::Round($totalSize, 1)) MB total"
        } else {
            Write-Host "ERROR: Failed to copy msedgewebview2.exe"
            $hasWebView2 = $false
        }
    } else {
        Write-Host "ERROR: msedgewebview2.exe not found in WebView2.Runtime.X64 package"
        Get-ChildItem -Path $RuntimeExtract -Recurse | Where-Object { $_.Name -like "*.exe" } | Select-Object FullName
        $hasWebView2 = $false
    }

    # Cleanup
    Remove-Item $RuntimePkg -Force -ErrorAction SilentlyContinue
    Remove-Item $RuntimeExtract -Recurse -Force -ErrorAction SilentlyContinue

} catch {
    Write-Host "ERROR: Could not download/extract WebView2 runtime: $_"
    Write-Host "MSI will require WebView2 Evergreen runtime on target system"
    $hasWebView2 = $false
}

if ($hasWebView2) {
    Write-Host ""
    Write-Host "WebView2 Fixed Version Runtime BUNDLED in MSI"
    Write-Host "MSI will work on Windows Server 2019 without any pre-installation"
} else {
    Write-Host ""
    Write-Host "WARNING: WebView2 runtime NOT bundled in MSI"
    Write-Host "MSI requires WebView2 Evergreen runtime (pre-installed on Win10+)"
}

# =============================================================================
# Step 6: Create Support Files
# =============================================================================
Write-Host ""
Write-Host "[6/7] Creating support files..."

$ReadmeContent = @"
Rescale Interlink $($env:RELEASE_TAG)
============================

Unified CLI and GUI for Rescale HPC platform.

Installation Directory: C:\Program Files\Rescale\Interlink\

Components:
- rescale-int-gui.exe  : GUI application (double-click to run)
- rescale-int.exe      : CLI tool (run from command prompt)
- rescale-int-tray.exe : System tray companion

Usage:
GUI Mode:
  Double-click rescale-int-gui.exe, or run from Start Menu

CLI Mode:
  rescale-int --help
  rescale-int jobs list
  rescale-int upload file.txt

Documentation:
  https://docs.rescale.com/

Support:
  support@rescale.com

Copyright (c) 2026 Rescale, Inc.
"@

$ReadmeContent | Out-File -FilePath "$BinDir\README.txt" -Encoding UTF8

$LicenseContent = @"
MIT License

Copyright (c) 2025 Rescale, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"@

$LicenseContent | Out-File -FilePath "$BinDir\LICENSE.txt" -Encoding UTF8

Write-Host "Support files created"

# =============================================================================
# Step 7: Build MSI Installer
# =============================================================================
Write-Host ""
Write-Host "[7/7] Building MSI installer..."

$InstallerDir = Join-Path $BuildDir "$($env:REPO_NAME)\installer"
$MsiName = "RescaleInterlink-$($env:RELEASE_TAG).msi"
$MsiPath = Join-Path $WorkDir $MsiName

Write-Host "Building MSI: $MsiPath"

# Build the wix command string and execute via cmd /c to avoid transcript console buffer conflicts
$VersionNum = $env:RELEASE_TAG -replace '^v', ''
$WxsFile = "$InstallerDir\rescale-interlink.wxs"
$wixBuildCmd = "wix build `"$WxsFile`" -d BuildDir=`"$BinDir`" -d SourceDir=`"$BinDir`" -d Version=`"$VersionNum`" -ext WixToolset.UI.wixext -o `"$MsiPath`""

Write-Host "Running: $wixBuildCmd"
$wixBuildResult = cmd /c "$wixBuildCmd 2>&1"
$wixBuildExitCode = $LASTEXITCODE
Write-Host $wixBuildResult

if ($wixBuildExitCode -ne 0) {
    throw "WiX build failed with exit code: $wixBuildExitCode"
}

if (-not (Test-Path $MsiPath)) { throw "Failed to build MSI - file not created" }

Write-Host "MSI built successfully"
Get-Item $MsiPath | Format-List Name, Length

# Generate checksum
$hash = (Get-FileHash -Path $MsiPath -Algorithm SHA256).Hash.ToLower()
$checksumFile = "$MsiName.sha256"
"$hash  $MsiName" | Out-File -FilePath (Join-Path $WorkDir $checksumFile) -Encoding ASCII
Write-Host "Checksum: $hash"

# =============================================================================
# Done
# =============================================================================
Write-Host ""
Write-Host "=============================================="
Write-Host "SUCCESS: MSI Build complete!"
Write-Host "=============================================="
Write-Host "Release: $($env:RELEASE_TAG)"
Write-Host "Package: $MsiName"
Write-Host "Location: $WorkDir\$MsiName"
Write-Host ""
Write-Host "Download from job results and upload to GitHub."
Write-Host "Completed: $(Get-Date)"

Stop-Transcript
PSBODY

chmod +x "$WRAPPER_SCRIPT"
echo "  Created: $WRAPPER_SCRIPT"
echo "  Created: $PS_SCRIPT"
echo ""

# =============================================================================
# Submit Job
# =============================================================================
echo "Uploading build scripts..."
WRAPPER_OUTPUT=$("$RESCALE_INT_BIN" upload "$WRAPPER_SCRIPT" 2>&1) || true
WRAPPER_FILE_ID=$(echo "$WRAPPER_OUTPUT" | grep -o 'FileID: [A-Za-z0-9]*' | head -1 | cut -d' ' -f2)
echo "$WRAPPER_OUTPUT"

PS_OUTPUT=$("$RESCALE_INT_BIN" upload "$PS_SCRIPT" 2>&1) || true
PS_FILE_ID=$(echo "$PS_OUTPUT" | grep -o 'FileID: [A-Za-z0-9]*' | head -1 | cut -d' ' -f2)
echo "$PS_OUTPUT"

if [ -z "$WRAPPER_FILE_ID" ] || [ -z "$PS_FILE_ID" ]; then
    echo "Uploading wrapper script..."
    "$RESCALE_INT_BIN" upload "$WRAPPER_SCRIPT"
    echo "Uploading PowerShell script..."
    "$RESCALE_INT_BIN" upload "$PS_SCRIPT"
    echo ""
    echo "Files uploaded. Create job manually with:"
    echo "  - Analysis: Bring Your Own Windows Software (user_included_win:1)"
    echo "  - Hardware: ${CORE_TYPE}, ${CORES_PER_SLOT} cores"
    echo "  - Command: interlink-msi-windows.bat"
    exit 0
fi

echo "  Wrapper script ID: $WRAPPER_FILE_ID"
echo "  PowerShell script ID: $PS_FILE_ID"
echo ""

# Create JSON job specification
JOB_JSON="/tmp/claude/interlink-msi-job.json"
cat > "$JOB_JSON" << EOF
{
  "name": "${JOB_NAME}",
  "jobanalyses": [
    {
      "analysis": {
        "code": "user_included_win",
        "version": "1"
      },
      "hardware": {
        "coreType": {"code": "${CORE_TYPE}"},
        "coresPerSlot": ${CORES_PER_SLOT},
        "slots": ${SLOTS},
        "walltime": ${WALLTIME_HOURS}
      },
      "command": "interlink-msi-windows.bat",
      "envVars": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}",
        "RELEASE_TAG": "${VERSION}",
        "REPO_OWNER": "${REPO_OWNER}",
        "REPO_NAME": "${REPO_NAME}"
      },
      "inputFiles": [
        {"id": "${WRAPPER_FILE_ID}"},
        {"id": "${PS_FILE_ID}"}
      ]
    }
  ]
}
EOF

echo "Submitting Windows MSI build job..."
"$RESCALE_INT_BIN" jobs submit --job-file "$JOB_JSON" --end-to-end

echo ""
echo "=============================================="
echo "BUILD COMPLETE"
echo "=============================================="
echo ""
echo "Download the MSI from job results and upload to GitHub:"
echo "  https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/tag/${VERSION}"
echo ""
