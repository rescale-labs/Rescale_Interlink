#!/bin/bash
#
# release-windows-wails-build.sh - Build Wails GUI for Windows on Rescale
#
# This script builds the Wails-based GUI application for Windows:
# 1. Installs Go 1.24.2, Node.js, and Wails CLI
# 2. Clones the repository
# 3. Builds the Wails GUI with FIPS 140-3 compliance
# 4. Downloads and bundles WebView2 Fixed Version Runtime
# 5. Creates a portable ZIP with EXE + webview2/
#
# Required environment variables:
#   RESCALE_API_KEY - Rescale API token
#   GITHUB_TOKEN - GitHub PAT with repo scope (for git clone)
#
# Output: rescale-interlink-{version}-windows-amd64.zip containing:
#   - rescale-int-gui.exe (Wails GUI application)
#   - rescale-int.exe (standalone CLI tool)
#   - webview2/ (Fixed Version Runtime for Windows Server 2019 compatibility)
#   - README.txt
#
# Usage:
#   ./release-windows-wails-build.sh
#
# Version: 4.0.2
# Date: 2026-01-01

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESCALE_INT_DIR="$(dirname "$SCRIPT_DIR")"
MAKEFILE="$RESCALE_INT_DIR/Makefile"

# Job configuration - Windows Server 2019
CORE_TYPE="calcitev2"
CORES_PER_SLOT=4  # More cores for faster npm/wails build
SLOTS=1
WALLTIME_HOURS=2  # 2 hours (Wails builds are slower than pure Go)

# GitHub repository
REPO_OWNER="rescale-labs"
REPO_NAME="Rescale_Interlink"

# =============================================================================
# Helper Functions
# =============================================================================
cleanup() {
    local exit_code=$?
    rm -f "/tmp/claude/interlink-wails-windows.ps1" 2>/dev/null || true
    rm -f "/tmp/claude/interlink-wails-windows.bat" 2>/dev/null || true
    if [ $exit_code -ne 0 ]; then
        echo ""
        echo "=============================================="
        echo "BUILD FAILED"
        echo "=============================================="
    fi
}
trap cleanup EXIT

error() {
    echo "ERROR: $1" >&2
    exit 1
}

# =============================================================================
# Pre-flight Checks
# =============================================================================
echo "=============================================="
echo "Rescale Interlink Windows Wails Builder"
echo "=============================================="
echo ""

[ -z "${RESCALE_API_KEY:-}" ] && error "RESCALE_API_KEY environment variable is not set"
[ -z "${GITHUB_TOKEN:-}" ] && error "GITHUB_TOKEN environment variable is not set"

[ ! -f "$MAKEFILE" ] && error "Makefile not found at: $MAKEFILE"

VERSION=$(grep -E '^VERSION\s*:=' "$MAKEFILE" | sed 's/.*:=\s*//' | tr -d '[:space:]')
[ -z "$VERSION" ] && error "Could not extract VERSION from Makefile"

BRANCH="release/${VERSION}"

echo "Version: $VERSION"
echo "Repository: ${REPO_OWNER}/${REPO_NAME}"
echo "Branch: ${BRANCH}"
echo ""

# Find rescale-int binary
RESCALE_INT_BIN="$RESCALE_INT_DIR/bin/${VERSION}/darwin-arm64/rescale-int"
if [ ! -x "$RESCALE_INT_BIN" ]; then
    RESCALE_INT_BIN=$(find "$RESCALE_INT_DIR/bin" -name "rescale-int" -type f 2>/dev/null | head -1)
fi
[ ! -x "$RESCALE_INT_BIN" ] && error "rescale-int binary not found. Please build it first with 'make build'"

echo "Using: $RESCALE_INT_BIN"
echo ""

# =============================================================================
# Generate Windows Build Scripts
# =============================================================================
echo "Generating Windows Wails build scripts..."

JOB_NAME="Interlink Windows Portable Build - ${VERSION}"

# Create wrapper batch file
WRAPPER_SCRIPT="/tmp/claude/interlink-wails-windows.bat"
cat > "$WRAPPER_SCRIPT" << 'WRAPPER_EOF'
@echo off
REM Wrapper to execute PowerShell Wails build script
echo ============================================
echo Starting PowerShell Wails build script...
echo ============================================

powershell.exe -ExecutionPolicy Bypass -File "%~dp0interlink-wails-windows.ps1"

echo ============================================
echo PowerShell script completed with exit code: %ERRORLEVEL%
echo ============================================
exit /b %ERRORLEVEL%
WRAPPER_EOF

# Create PowerShell build script
PS_SCRIPT="/tmp/claude/interlink-wails-windows.ps1"
cat > "$PS_SCRIPT" << PSHEADER
# Rescale Interlink Windows Wails Build Script
# Generated by release-windows-wails-build.sh
# Version: ${VERSION}

\$ErrorActionPreference = "Stop"

PSHEADER

# Add the main build logic
cat >> "$PS_SCRIPT" << 'PSBODY'
Write-Host "=============================================="
Write-Host "Rescale Interlink Windows Wails Build"
Write-Host "=============================================="
Write-Host "Release Tag: $env:RELEASE_TAG"
Write-Host "Repository: $env:REPO_OWNER/$env:REPO_NAME"
Write-Host "Started: $(Get-Date)"
Write-Host ""

# Set up paths
$WorkDir = $PWD.Path
$BuildDir = "C:\build"
$LogFile = Join-Path $WorkDir "build.log"

New-Item -ItemType Directory -Force -Path $BuildDir | Out-Null
Start-Transcript -Path $LogFile -Append

Write-Host "Build log: $LogFile"
Write-Host "Work directory: $WorkDir"
Write-Host "Build directory: $BuildDir"

Set-Location $BuildDir

$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# =============================================================================
# Helper Function: Run noisy tools without console buffer issues
# =============================================================================
function Invoke-ToolQuiet {
    param(
        [Parameter(Mandatory = $true)][string]$FilePath,
        [Parameter(Mandatory = $true)][string]$Arguments,
        [Parameter(Mandatory = $true)][string]$LogName
    )

    # Write logs to work directory so they're captured in job output
    $stdoutLog = Join-Path $WorkDir "$LogName-stdout.log"
    $stderrLog = Join-Path $WorkDir "$LogName-stderr.log"

    Write-Host "Running: $FilePath $Arguments"
    Write-Host "  stdout -> $stdoutLog"
    Write-Host "  stderr -> $stderrLog"

    $proc = Start-Process -FilePath $FilePath `
                          -ArgumentList $Arguments `
                          -Wait `
                          -PassThru `
                          -RedirectStandardOutput $stdoutLog `
                          -RedirectStandardError $stderrLog

    if ($null -ne $proc.ExitCode -and $proc.ExitCode -ne 0) {
        Write-Host "Command failed with exit code $($proc.ExitCode). Last 50 lines of stderr:"
        if (Test-Path $stderrLog) {
            Get-Content $stderrLog -Tail 50
        }
        throw "Command '$FilePath $Arguments' failed with exit code $($proc.ExitCode)"
    }
}

# =============================================================================
# Helper Function: Ensure Chocolatey is installed
# =============================================================================
function Ensure-Chocolatey {
    if (Get-Command choco.exe -ErrorAction SilentlyContinue) {
        Write-Host "Chocolatey already installed"
        return
    }

    Write-Host "Installing Chocolatey..."
    Set-ExecutionPolicy Bypass -Scope Process -Force
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

    if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
        throw "Chocolatey installation failed"
    }
    Write-Host "Chocolatey installed successfully"
}

# =============================================================================
# Step 1: Install Go 1.24.2
# =============================================================================
Write-Host ""
Write-Host "[1/7] Installing Go 1.24.2..."

$GoVersion = "1.24.2"
$GoZip = "go${GoVersion}.windows-amd64.zip"
$GoUrl = "https://go.dev/dl/$GoZip"
$GoInstallDir = "C:\Go"

Write-Host "Downloading Go from: $GoUrl"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
(New-Object System.Net.WebClient).DownloadFile($GoUrl, (Join-Path $BuildDir $GoZip))

Write-Host "Extracting Go..."
if (Test-Path $GoInstallDir) {
    Remove-Item -Recurse -Force $GoInstallDir
}
Expand-Archive -Path (Join-Path $BuildDir $GoZip) -DestinationPath "C:\" -Force
Remove-Item (Join-Path $BuildDir $GoZip)

$env:PATH = "$GoInstallDir\bin;$env:PATH"
$env:GOPATH = "$env:USERPROFILE\go"
$env:PATH = "$env:GOPATH\bin;$env:PATH"

Write-Host "Go version:"
$goResult = cmd /c "go version 2>&1"
Write-Host $goResult

# =============================================================================
# Step 2: Install Node.js (for frontend build)
# =============================================================================
Write-Host ""
Write-Host "[2/7] Installing Node.js..."

Ensure-Chocolatey

Invoke-ToolQuiet -FilePath "choco" `
                 -Arguments "install nodejs-lts -y --no-progress --limit-output" `
                 -LogName "choco-nodejs"

# Refresh PATH
$env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" +
            [System.Environment]::GetEnvironmentVariable("PATH", "User") + ";" +
            "$GoInstallDir\bin;$env:GOPATH\bin"

Write-Host "Node.js version:"
$nodeResult = cmd /c "node --version 2>&1"
Write-Host $nodeResult
Write-Host "npm version:"
$npmResult = cmd /c "npm --version 2>&1"
Write-Host $npmResult

# =============================================================================
# Step 3: Install Git and Clone Repository
# =============================================================================
Write-Host ""
Write-Host "[3/7] Setting up Git and cloning repository..."

$GitPath = Get-Command git -ErrorAction SilentlyContinue
if (-not $GitPath) {
    Write-Host "Installing Git..."
    Invoke-ToolQuiet -FilePath "choco" `
                     -Arguments "install git -y --no-progress --limit-output" `
                     -LogName "choco-git"

    $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" +
                [System.Environment]::GetEnvironmentVariable("PATH", "User") + ";" +
                "$GoInstallDir\bin;$env:GOPATH\bin"
}

Write-Host "Git version:"
$gitResult = cmd /c "git --version 2>&1"
Write-Host $gitResult

$RepoUrl = "https://x-access-token:$($env:GITHUB_TOKEN)@github.com/$($env:REPO_OWNER)/$($env:REPO_NAME).git"
$BranchName = "release/$($env:RELEASE_TAG)"

Write-Host "Cloning repository (branch: $BranchName)..."
Invoke-ToolQuiet -FilePath "git" `
                 -Arguments "clone --depth 1 --branch $BranchName $RepoUrl" `
                 -LogName "git-clone"

if (-not (Test-Path $env:REPO_NAME)) { throw "Git clone failed" }
Write-Host "Repository cloned successfully"

# =============================================================================
# Step 4: Install Wails CLI
# =============================================================================
Write-Host ""
Write-Host "[4/7] Installing Wails CLI..."

$GoExe = "$GoInstallDir\bin\go.exe"
Invoke-ToolQuiet -FilePath $GoExe `
                 -Arguments "install github.com/wailsapp/wails/v2/cmd/wails@latest" `
                 -LogName "go-install-wails"

Write-Host "Wails version:"
$wailsResult = cmd /c "$env:GOPATH\bin\wails.exe version 2>&1"
Write-Host $wailsResult

# =============================================================================
# Step 5: Build Wails Application (GUI)
# =============================================================================
Write-Host ""
Write-Host "[5/7] Building Wails GUI application with FIPS 140-3..."

Set-Location $env:REPO_NAME

$BuildTime = Get-Date -Format "yyyy-MM-dd"
$LdFlags = "-s -w -X main.Version=$($env:RELEASE_TAG) -X main.BuildTime=$BuildTime"

Write-Host "Build flags: GOFIPS140=latest"
Write-Host "LDFLAGS: $LdFlags"

$env:GOFIPS140 = "latest"

# Install frontend dependencies
Write-Host "Installing frontend dependencies..."
Set-Location frontend
# Use cmd /c to ensure npm is found via PATH (Chocolatey PATH may not be refreshed in Start-Process)
Invoke-ToolQuiet -FilePath "cmd.exe" `
                 -Arguments "/c npm install" `
                 -LogName "npm-install"
Set-Location ..

# Build with Wails
# Use cmd.exe wrapper to ensure GOFIPS140 environment variable is properly inherited
# NOTE: No space between "latest" and "&&" - spaces would become part of the env var value!
$WailsExe = "$env:GOPATH\bin\wails.exe"
$wailsBuildCmd = "set `"GOFIPS140=latest`"&& `"$WailsExe`" build -platform windows/amd64 -ldflags `"$LdFlags`""
Write-Host "Running (via cmd): $wailsBuildCmd"
Invoke-ToolQuiet -FilePath "cmd.exe" `
                 -Arguments "/c $wailsBuildCmd" `
                 -LogName "wails-build"

$WailsExePath = "build\bin\rescale-int.exe"
if (-not (Test-Path $WailsExePath)) { throw "Wails build failed - EXE not created" }

# v4.0.2: Rename Wails output to rescale-int-gui.exe
$GuiExePath = "build\bin\rescale-int-gui.exe"
Rename-Item -Path $WailsExePath -NewName "rescale-int-gui.exe"
Write-Host "GUI binary built: rescale-int-gui.exe"

# =============================================================================
# Step 6: Build Standalone CLI
# =============================================================================
Write-Host ""
Write-Host "[6/7] Building standalone CLI with FIPS 140-3..."

# Build CLI-only binary (no Wails, just Go)
$GoExe = "$GoInstallDir\bin\go.exe"
$cliBuildCmd = "set `"GOFIPS140=latest`"&& `"$GoExe`" build -ldflags `"$LdFlags`" -o build\bin\rescale-int.exe .\cmd\rescale-int"
Write-Host "Running (via cmd): $cliBuildCmd"
Invoke-ToolQuiet -FilePath "cmd.exe" `
                 -Arguments "/c $cliBuildCmd" `
                 -LogName "go-build-cli"

$CliExePath = "build\bin\rescale-int.exe"
if (-not (Test-Path $CliExePath)) { throw "CLI build failed - EXE not created" }

Write-Host "CLI binary built: rescale-int.exe"
Write-Host ""
Write-Host "Build outputs:"
Get-ChildItem "build\bin\*.exe" | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 1)) MB)" }

# =============================================================================
# Step 7: Create Package with Bundled WebView2 Fixed Version Runtime
# =============================================================================
Write-Host ""
Write-Host "[7/7] Creating package with bundled WebView2 Fixed Version Runtime..."

# Create output directory
$OutputDir = Join-Path $BuildDir "package"
$WebView2Dir = Join-Path $OutputDir "webview2"
New-Item -ItemType Directory -Force -Path $OutputDir | Out-Null
New-Item -ItemType Directory -Force -Path $WebView2Dir | Out-Null

# Download WebView2 Fixed Version Runtime from NuGet
# IMPORTANT: Use WebView2.Runtime.X64 package (contains actual runtime files)
# NOT Microsoft.Web.WebView2 (which is just the SDK with WebView2Loader.dll)
# See: https://github.com/ProKn1fe/WebView2.Runtime
$RuntimeNuGetUrl = "https://www.nuget.org/api/v2/package/WebView2.Runtime.X64"
$RuntimePkg = Join-Path $BuildDir "webview2-runtime.zip"  # .zip extension required for Expand-Archive

Write-Host "Downloading WebView2 Fixed Version Runtime from NuGet (WebView2.Runtime.X64)..."
$hasRuntime = $false

try {
    (New-Object System.Net.WebClient).DownloadFile($RuntimeNuGetUrl, $RuntimePkg)
    Write-Host "WebView2.Runtime.X64 package downloaded successfully"
    $pkgSize = (Get-Item $RuntimePkg).Length / 1MB
    Write-Host "Package size: $([math]::Round($pkgSize, 1)) MB"

    # Extract the NuGet package (it's a zip file)
    $RuntimeExtract = Join-Path $BuildDir "webview2-runtime-extract"
    Expand-Archive -Path $RuntimePkg -DestinationPath $RuntimeExtract -Force

    Write-Host "Searching for runtime files in extracted package..."

    # WebView2.Runtime.X64 package structure varies - find msedgewebview2.exe
    $runtimeExe = Get-ChildItem -Path $RuntimeExtract -Recurse -Filter "msedgewebview2.exe" | Select-Object -First 1

    if ($runtimeExe) {
        $RuntimeSourceDir = $runtimeExe.DirectoryName
        Write-Host "Found runtime at: $RuntimeSourceDir"

        # Copy all runtime files from that directory
        Copy-Item -Path "$RuntimeSourceDir\*" -Destination $WebView2Dir -Recurse -Force
        $hasRuntime = $true

        # v4.0.1: Strip unnecessary components to avoid path length issues and reduce size
        # - WidevineCdm: DRM for video playback - not needed for Interlink
        # - EBWebView/x86: 32-bit components - Interlink is 64-bit only
        Write-Host "Stripping unnecessary WebView2 components..."
        $strippedSize = 0

        $widevinePath = Join-Path $WebView2Dir "WidevineCdm"
        if (Test-Path $widevinePath) {
            $wvSize = (Get-ChildItem -Path $widevinePath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Remove-Item -Recurse $widevinePath -Force -ErrorAction SilentlyContinue
            Write-Host "  Removed WidevineCdm/ ($([math]::Round($wvSize, 1)) MB)"
            $strippedSize += $wvSize
        }

        $x86Path = Join-Path $WebView2Dir "EBWebView\x86"
        if (Test-Path $x86Path) {
            $x86Size = (Get-ChildItem -Path $x86Path -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Remove-Item -Recurse $x86Path -Force -ErrorAction SilentlyContinue
            Write-Host "  Removed EBWebView/x86/ ($([math]::Round($x86Size, 1)) MB)"
            $strippedSize += $x86Size
        }

        if ($strippedSize -gt 0) {
            Write-Host "  Total stripped: $([math]::Round($strippedSize, 1)) MB"
        }

        # Verify key files
        $copiedExe = Join-Path $WebView2Dir "msedgewebview2.exe"
        if (Test-Path $copiedExe) {
            Write-Host "SUCCESS: msedgewebview2.exe bundled"
            $fileCount = (Get-ChildItem -Path $WebView2Dir -Recurse).Count
            $totalSize = (Get-ChildItem -Path $WebView2Dir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
            Write-Host "WebView2 runtime: $fileCount files, $([math]::Round($totalSize, 1)) MB total"
        } else {
            Write-Host "ERROR: Failed to copy msedgewebview2.exe"
            $hasRuntime = $false
        }
    } else {
        Write-Host "ERROR: msedgewebview2.exe not found in package"
        Write-Host "Package contents:"
        Get-ChildItem -Path $RuntimeExtract -Recurse | Where-Object { $_.Name -like "*.exe" -or $_.Name -like "*.dll" } | Select-Object FullName | ForEach-Object { Write-Host "  $_" }
        $hasRuntime = $false
    }

    # Cleanup temp files
    Remove-Item $RuntimePkg -Force -ErrorAction SilentlyContinue
    Remove-Item $RuntimeExtract -Recurse -Force -ErrorAction SilentlyContinue

} catch {
    Write-Host "ERROR: Could not download/extract WebView2 runtime: $_"
    Write-Host ""
    Write-Host "Falling back to Evergreen runtime dependency..."
    Write-Host "Package will require WebView2 Evergreen runtime on target system"
    $hasRuntime = $false
}

# Verify we have a working runtime bundle
if ($hasRuntime) {
    Write-Host ""
    Write-Host "WebView2 Fixed Version Runtime BUNDLED SUCCESSFULLY"
    Write-Host "This package will work on Windows Server 2019 without any installation"
} else {
    Write-Host ""
    Write-Host "WARNING: WebView2 runtime NOT bundled"
    Write-Host "Package requires WebView2 Evergreen runtime (pre-installed on Win10+)"
}

# Copy both EXEs
Copy-Item $GuiExePath -Destination $OutputDir
Copy-Item $CliExePath -Destination $OutputDir
Write-Host "Copied: rescale-int-gui.exe and rescale-int.exe"

# Create README
if ($hasRuntime) {
    $WebView2Section = @"
WebView2 Runtime (BUNDLED)
==========================
This distribution includes WebView2 Fixed Version Runtime in the webview2/ folder.
The application automatically uses the bundled runtime - NO installation required.

Works out-of-the-box on:
- Windows 10 (any version)
- Windows 11
- Windows Server 2019
- Windows Server 2022

No admin rights, no internet connection, no manual installation needed.
"@
} else {
    $WebView2Section = @"
WebView2 Runtime
================
Windows 10 (1903+) and Windows 11 have WebView2 pre-installed.

For Windows Server 2019 or systems without WebView2:
Download and run the WebView2 installer from:
https://developer.microsoft.com/en-us/microsoft-edge/webview2/
"@
}

$ReadmeContent = @"
Rescale Interlink $($env:RELEASE_TAG) - Windows (amd64)

SELF-CONTAINED PORTABLE DISTRIBUTION
====================================
Just extract and run - no installation required.
WebView2 runtime is bundled - works on any Windows system.

Files
=====
- rescale-int-gui.exe  GUI application (double-click to run)
- rescale-int.exe      CLI tool (run from command prompt)
- webview2/            Bundled WebView2 runtime
- README.txt           This file

Usage
=====
GUI Mode:
  Double-click rescale-int-gui.exe

CLI Mode:
  rescale-int.exe --help
  rescale-int.exe jobs list
  rescale-int.exe upload file.txt

$WebView2Section

Windows SmartScreen
===================
You may see a Windows SmartScreen warning on first run.
Click "More info" then "Run anyway" to proceed.

Documentation
=============
https://docs.rescale.com
https://github.com/rescale-labs/Rescale_Interlink

Copyright (c) 2026 Rescale, Inc.
"@
$ReadmeContent | Out-File -FilePath (Join-Path $OutputDir "README.txt") -Encoding UTF8

# Create ZIP
$ZipName = "rescale-interlink-$($env:RELEASE_TAG)-windows-amd64.zip"
$ZipPath = Join-Path $BuildDir $ZipName

Write-Host "Creating ZIP package..."
Compress-Archive -Path (Join-Path $OutputDir "*") -DestinationPath $ZipPath -Force

Write-Host "Packaged as: $ZipName"
Get-Item $ZipPath | Format-List Name, Length

# Copy to work directory
Copy-Item $ZipPath -Destination $WorkDir
Write-Host "Package copied to: $WorkDir\$ZipName"

# Generate checksum
$hash = (Get-FileHash -Path $ZipPath -Algorithm SHA256).Hash.ToLower()
$checksumFile = "$ZipName.sha256"
"$hash  $ZipName" | Out-File -FilePath (Join-Path $WorkDir $checksumFile) -Encoding ASCII
Write-Host "Checksum: $hash"

# =============================================================================
# Done
# =============================================================================
Write-Host ""
Write-Host "=============================================="
Write-Host "SUCCESS: Build complete!"
Write-Host "=============================================="
Write-Host "Release: $($env:RELEASE_TAG)"
Write-Host "Package: $ZipName"
Write-Host "Location: $WorkDir\$ZipName"
Write-Host ""
Write-Host "Download from job results and upload to GitHub."
Write-Host "Completed: $(Get-Date)"

Stop-Transcript
PSBODY

chmod +x "$WRAPPER_SCRIPT"
echo "  Created: $WRAPPER_SCRIPT"
echo "  Created: $PS_SCRIPT"
echo ""

# =============================================================================
# Submit Job
# =============================================================================
echo "Uploading build scripts..."
WRAPPER_OUTPUT=$("$RESCALE_INT_BIN" upload "$WRAPPER_SCRIPT" 2>&1) || true
WRAPPER_FILE_ID=$(echo "$WRAPPER_OUTPUT" | grep -o 'FileID: [A-Za-z0-9]*' | head -1 | cut -d' ' -f2)
echo "$WRAPPER_OUTPUT"

PS_OUTPUT=$("$RESCALE_INT_BIN" upload "$PS_SCRIPT" 2>&1) || true
PS_FILE_ID=$(echo "$PS_OUTPUT" | grep -o 'FileID: [A-Za-z0-9]*' | head -1 | cut -d' ' -f2)
echo "$PS_OUTPUT"

if [ -z "$WRAPPER_FILE_ID" ] || [ -z "$PS_FILE_ID" ]; then
    echo "Uploading wrapper script..."
    "$RESCALE_INT_BIN" upload "$WRAPPER_SCRIPT"
    echo "Uploading PowerShell script..."
    "$RESCALE_INT_BIN" upload "$PS_SCRIPT"
    echo ""
    echo "Files uploaded. Create job manually with:"
    echo "  - Analysis: Bring Your Own Windows Software (user_included_win:1)"
    echo "  - Hardware: ${CORE_TYPE}, ${CORES_PER_SLOT} cores"
    echo "  - Command: interlink-wails-windows.bat"
    exit 0
fi

echo "  Wrapper script ID: $WRAPPER_FILE_ID"
echo "  PowerShell script ID: $PS_FILE_ID"
echo ""

# Create JSON job specification
JOB_JSON="/tmp/claude/interlink-windows-wails-job.json"
cat > "$JOB_JSON" << EOF
{
  "name": "${JOB_NAME}",
  "jobanalyses": [
    {
      "analysis": {
        "code": "user_included_win",
        "version": "1"
      },
      "hardware": {
        "coreType": {"code": "${CORE_TYPE}"},
        "coresPerSlot": ${CORES_PER_SLOT},
        "slots": ${SLOTS},
        "walltime": ${WALLTIME_HOURS}
      },
      "command": "interlink-wails-windows.bat",
      "envVars": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}",
        "RELEASE_TAG": "${VERSION}",
        "REPO_OWNER": "${REPO_OWNER}",
        "REPO_NAME": "${REPO_NAME}"
      },
      "inputFiles": [
        {"id": "${WRAPPER_FILE_ID}"},
        {"id": "${PS_FILE_ID}"}
      ]
    }
  ]
}
EOF

echo "Submitting Windows Wails build job..."
"$RESCALE_INT_BIN" jobs submit --job-file "$JOB_JSON" --end-to-end

echo ""
echo "=============================================="
echo "BUILD COMPLETE"
echo "=============================================="
echo ""
echo "Download the package from job results and upload to GitHub:"
echo "  https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/tag/${VERSION}"
echo ""
